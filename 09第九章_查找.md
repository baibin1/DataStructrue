[TOC]

### 查找的定义与术语

- 查找表（Search Table）：有同一类数据元素或记录构成的集合；

- 静态查找表（Static Search Table）：对查找表只作‘查找’操作；

- 动态查找表（Dynamic Search Table）：在查找的过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素；

- 关键字（Key）：数据元素（或记录）中某个数据项的值，用它可以标识（识别）一个数据元素（或记录）；

- 主关键字（Primary Key）：关键字可以惟一地标识一个记录；

- 次关键字（Secondary Key）：用以识别若干记录地关键字；

- 平均查找长度（Average Search Length）：为确定记录在查找表中地位置，需和给定值进行比较地关键字个数地期望值；
  $$
  ASL = \sum^n_i P_iC_i(i = 0,1,2,...)
  $$

### 静态查找

#### 顺序查找

- 顺序查找又称为线性查找，它对顺序表和链表都适用；

##### 一般线性表的顺序查找

- 引入‘哨兵’ST.elem[0] = key目的：使得查找地循环不必判断数组是否会越界，从而提高程序地效率；
- 当每个元素查找的概率相等时，$$ASL_成 = \sum^n_i P_i(n-i+1) = \frac{n+1}{2}$$；$$ASL_败  = n + 1$$；
- 时间复杂度为$$O(n)$$；
- 顺序查找的缺点：当n比较大时，平均查找长度较大，效率低；
- 顺序查找优点：对数据元素的存储没有要求；对表中记录的有序性也没有要求；对线性的链表只能进行顺序查找；

##### 有序表的线性查找

- $$ASL_成 = \sum^n_i P_i(n-i+1) = \frac{n+1}{2}$$；$$ASL_败  = n + 1$$；
- 查找失败时，查找指针走到了某个失败的虚构的空结点，有n个结点就有n+1个查找失败的结点，$$ASL_败 = \frac{1+2+...+n+n}{n+1} = \frac{n}{2}+\frac{n}{n+1}$$；
- 比一般顺序查找算法效率好一些；

#### 折半查找（二分查找）

- 以有序表表示静态查找时，可以通过折半查找实现；Binary Search：先确定待查记录的范围，然后逐步缩小范围直到找到或找不到该记录为止；

  ```c
  //-------二分查找算法实现---------
  int Binary_Search(SeqList L,ElemType key){
      int low = 0,high = L.TableLen - 1,mid;
      while(low <= high){
          mid = (low + high)/2;						//取中间位置
          if(L.elem[mid] == key)
              	return mid;							//查找成功，返回所在位置
          else if(L.elem[mid] < key)
              	low = mid + 1;
          	else
                  high = mid - 1;
      }
      return -1;										//查找失败，返回-1；
  }
  ```

- n个元素的有序列表，对应的判定树有n个圆形的非叶结点和n+1个方形的叶节点，圆形结点查找成功，方形节点查找失败；
- 查找成功的平均查找长度为：$$ASL = \frac{1}{n}\sum^n_ll_i = \frac{1}{n}(1\times1+2\times2+...+h\times2^(h-1) \approx \frac{n+1}{n}log_2(n+1)-1 \approx log_2(n+1)-1$$；h为树高，元素为n个时，树高h = [$$log_2(n+1)$$]，时间复杂度为$$O(log_2n)$$；
- 折半查找的效率比顺序查找高，但折半查找只适用于有序表且限于顺序存储结构，因为它要求线性表必须有随机存取的特性；

#### 静态树表的查找

- 如果只考虑查找成功的情况，使查找性能最佳的判定树是其带权内路径长度之和PH值$$PH = \sum^n_iw_ih_i(i = 1,2,3,...,n)$$；
- 静态最优查找树（Static Optimal Search Tree）：PH值取最小的二叉树；
- 次优查找树（Nearly Optimal Search Tree）：PH值在所有具有同样权值的二叉树中近似为最小；

#### 分块查找

- 分块查找又称为索引顺序查找，它吸收了顺序查找和折半查找各自的优点，既有动态结构，又适用于快速查找；

  ```c
  //-------索引表定义如下--------
  typedef struct{
      int key;							//表内元素
      int low,high;						//记录某块中第一个和最后一个元素的位置
  }indexElem;
  indexElem index[MaxSize];				//定义索引表，MaxSize已定义的常量
  ```

- 每一块中元素存储顺序是任意的，但块与块之间必须按照关键字大小有序排列；
- 分块查找的过程分为两步：第一步是在索引表中确定待查找元素所在的块，可以在顺序查找或折半查找索引表；第二步是在块内顺序查找；
- 整个算法的平均查找长度是两次查找的平均查找长度之和，即二分查找平均查找长度+顺序查找平均查找长度；

### 树型查找

#### 二叉排序树（BST）

##### 定义

- 二叉排序树也称二叉查找树或者是一颗空树，或者是具有下列特性的二叉树：
  1. 若左子树非空，则左子树上所有结点的值均小于根结点的值；
  2. 若右子树非空，则右子树上所有结点的值均大于根结点的值；
  3. 左右子树也分别是一颗二叉排序树；

- 左子树结点值$$<$$根结点值$$<$$右子树结点值，对二叉排序树进行中序遍历，可以得到一个递增的有序序列；

##### 存储结构

- 采用二叉链表进行存储：

  ```c
  typedef struct BTNode{
      int key;						//关键字
      struct BTNode *lchild,*rchild;
  }BTNode;
  ```

##### 查找

- 二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程；

  ```c
  //------二叉排序树查找的递归算法-------
  BTNode* BSTSearch(BTNode* bt,int key){
      if(bt == NULL)
          return NULL;
      else
      {
          if(bt->key == key)
              return bt;
          else if(bt-<key > key)
              return BSTSearch(bt->lchild,key);
          else
              return BSTSearch(bt->rchild,key);
      }
  }
  //-------二叉排序树查找的非递归算法-------
  BTNode* BSTSearch(BTNode* bt,int key){
      while(bt!=NULL && bt->key != key){
          if(bt->key > key)
              bt = bt->lchild;
          else
              bt = bt->rchild;
      }
      return bt;
  }
  ```

##### 插入

- 对于一个不存在于二叉排序树中的关键字，其查找不成功的位置即为该关键字的插入位置；

  ```c
  //------二叉排序树插入的递归算法------
  int BSTInsert(BTNode* &bt,int key){
      if(bt == NULL){
          bt = (BTNode*)malloc(sizeof(BTNode));
          bt->key = key;
          bt->lchild = bt->rchild = NULL;
          return 1;
      }
      else if(bt->key = key)
          return 0;
      else if(bt->key > key)
          return BSTInsert(bt->lchild,key);
      else
          return BSTInsert(bt->rchild,key);
  }
  ```

##### 构造

- 假设关键字已经存入数组key[ ]中：

  ```c
  //--------二叉排序树的构造----------
  void CreateBST(BTNode* &bt,int key[],int n){
      bt = NULL;							//初始化为空
      for(int i = 0; i < n; i++)
          BSTInsert(bt,key[i]);
  }
  ```

##### 删除

- 删除操作的实现过程按三种情况来处理：
  1. 若被删除的结点为叶结点，直接删除；
  2. 若被删除的结点只有一颗左子树或右子树，则让该结点的子树成为该结点的父结点的子树，替代该结点的位置；
  3. 若结点有左右两颗子树，则令该结点的直接后继（或直接前驱）代替该结点，然后从二叉排序中删去这个直接后继（或直接前驱）从而转化成第一种或第二种情况；

- ```c
  //-------二叉排序树删除结点算法---------
  bool DeleteBST(BTree &T,char key){
  	if(!T) return false;
      else{
          if(EQ(key,T->data.key))	{return Delete(T)};
          else if(LT(key,T->data.key)) return DeleteBST(T->lchild,key);
          else return DeleteBSt(T->rchild,key);
      }
  }
  void Delete(BTree &p){
  	if(p->rchild == NULL)
  	{
  		q = p;p = p->lchild;free(q);
  	}
  	else if(p->lchild == NULL)
  	{
  		q = p;p = p->rchild;free(q);
  	}
  	else
  	{
  		q = p;s = p->lchild;
  		while(s->rchild)	{q = s;	s = s->rchild;}
  		p->key = s->key;
  		if(q!=p) 	q->rchild = s->lchild;
  		else	q->lchild = s->lchild;
  		delete s; 
  	}
  }
  ```

##### 查找效率分析及与二分查找的比较

- 二叉排序树的查找性能主要取决于树的高度，若二叉排序树的左、右子树的高度之差的绝对值不超过1，则成为平衡二叉树，平均查找长度为$$O(log_2n)$$；对单支树（类似有序的单链表）平均查找长度为$$O(n)$$；
- 从过程看二叉排序树与二分查找相似，就平均时间性能而言，二叉排序树的查找和二分查找差不多，但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同关键字其插入顺序不同可能生成不同的二叉排序树；
- 就维护表的有序性而言，二叉排序树无需移动结点，只需修改指针就能完成插入和删除操作，平均执行时间为$$O(log_2n)$$，二分查找的对象是有序顺序表，若有插入和删除操作，所花的代价是$$O(n)$$；
- 当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其操作；若有序表是动态查找表，则应采用二叉排序树作为其逻辑结构；

#### 平衡二叉树 

##### 定义

- 平衡二叉树又称为AVL树，是一种特殊的二叉排序树，其左右子树都为平衡二叉树且左右子树高度之差的绝对值不超过1：以树中所有结点为根的树的左右子树高度之差的绝对值不超过1；
- 平衡因子：左子树与右子树的高度差，可能取值为-1、0、1；
- 平衡调整：当平衡失去时，首先要找到失去平衡的最小子树，然后调整这颗子树，使之成为平衡子树；当失去平衡的最小子树调整为平衡子树后，无需调整原有其他所有的不平衡子树，整个二叉排序树就会称成为一颗平衡二叉树；
- 最小不平衡子树：距离插入结点最近且以平衡因子绝对值大于1的结点作为根结点的子树；

##### 插入 - 平衡调整

- LL平衡调整（右单旋转）：在结点的左孩子的左子树上插入了新结点，结点的平衡因子由1增至2，导致以该结点为根的子树失去平衡，需要一次向右的旋转操作；
- RR平衡调整（左单旋转）：在结点的右孩子的右子树上插入了新结点，结点的平衡因子由1增至2，导致以该结点为根的子树失去平衡，需要一次向左的旋转操作；
- LR平衡调整（先左后右双旋转）：在结点的左孩子的右子树上插入了新结点，结点的平衡因子由1增至2，导致以该结点为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转；
- RL平衡调整（先右后左双旋转）：在结点的右孩子的左子树上插入了新结点，结点的平衡因子由1增至2，导致以该结点为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转；

##### 删除 - 平衡调整

- 删除结点w的步骤：
  1. 用二叉排序树的方法对结点w执行删除操作；
  2. 从结点w开始向上回溯，找到第一个不平衡的结点z（即最小不平衡子树）；y为z的高度最高的孩子结点；x是y的高度最高的孩子结点；
  3. 然后对以z为根的子树进行平衡调整，其中x、y、z可能的位置情况有4种情况：
     - y是z的左孩子，x是y的左孩子（LL，右单旋转）；
     - y是z的左孩子，x是y的右孩子（LR，先左后右双旋转）；
     - y是z的右孩子，x是y的右孩子（RR，左单旋转）；
     - y是z的右孩子，x是y的左孩子（RL，先右后左双旋转）；

##### 查找

- $$n_k$$表示深度为h的平衡树中含有的最少结点数，$$n_0=0，n_1=1，n_2=2，... ，n_k = n_(k-1)+n_(k-2)+1$$；含有n个结点的平衡二叉树的深度为$$O(log_2n)$$，所以平衡二叉树的平均查找长度为$$O(log_2n)$$；

#### 红黑树

##### 定义

- 为了保持AVL树的平衡性，插入和删除操作后，非常频繁的调整全树整体拓扑结构，代价较大；为此在AVL树的平衡标准上进一步放宽条件，引入红黑树结构，该结构满足如下性质：
  1. 每个结点或是红色，或是黑色；
  2. 根结点是黑色的；
  3. 叶结点（虚构的外部节点、NULL）都是黑色的；
  4. 不存在两个相邻的红结点；
  5. 对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数量相同；

- 4和5使红黑树有了一个关键特性：从根结点到叶结点的最长可能路径不多于最短可能路径的两倍；
- 含有n个结点的红黑树高度至多为$$2log_2(n+1)$$；
- 红黑树查找的时间复杂度为$$O(log_2n)$$；
- 插入和删除的时间复杂度为$$O(log_2n)$$；

##### 插入

- 新插入结点的初始着色为红色；
- 情况1：被插入结点时根结点，直接涂为黑色即可；
- 情况2：被插入结点的父结点是黑色结点，直接插入即可；
- 情况3：被插入结点z的父结点z.p是红色结点：
  1. z的叔结点y是黑色的且z是一个右孩子；
  2. z的叔结点y是黑色的且z是一个左孩子；
  3. x的叔结点y是红色的；

##### 删除

- 删除过程先执行二叉查找树的删除方法，若待删除结点有两个孩子不能直接删除，而要找到该结点的中序后继（或前驱）填补，即右子树的最小结点，然后转换为删除该后继结点；由于后继结点至多只有一个孩子，这样就转换为待删除结点是叶结点或仅有一个孩子的情况；

- 待删除结点没有孩子；
- 待删除结点只有左子树或右子树；

#### B树

##### 定义

- B树又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示；一颗m阶B树或为空树或为满足以下特性的m叉树：

  1. 树中每个结点至多有m棵子树，即至多含有m-1个关键字；

  2. 若根结点不是终端结点，则至少含有两颗子树；

  3. 除根结点外的所有非叶结点至少有[m/2]棵子树，即至少含有[m/2]-1个关键字；

  4. 所有的叶结点均出现在同一层次上，并不带任何信息；

  5. 所有非叶结点的结构为：

     |  $$n$$  | $$k_1$$ | $$k_2$$ | $$...$$ | $$K_n$$ |
     | :-----: | :-----: | :-----: | :-----: | :-----: |
     | $$p_0$$ | $$p_1$$ | $$p_2$$ | $$...$$ | $$p_n$$ |

     n为该结点中关键字的个数，$$k_i<k_(i+1)$$；$$p_i$$为该结点的孩子结点指针且满足$$p_i$$所指结点上的关键字大于$$k_i$$小于$$k_(i+1)$$；

- B树是所有结点的平衡因子均等于0的多路平衡查找树；

##### B树的高度

- B树中大部分操作所需的磁盘读取次数与B树的高度成正比；
- 若n $$\geqq$$ 1，则对任意一颗包含n个关键字、高度为h、阶数为m的B树：
  1. 在一颗高度为h的m阶B树中关键词的个数应该满足$$n \leqq(m-1)(1+m+m^2+...+m^(h-1))$$，因此$$h \geqq log_m(n+1)$$；
  2. 叶结点即查找不成功的结点为n+1，由此有$$n+1\geqq2([m/2])^(k-1)$$，即$$h \leqq log_[m/2]  \frac{n+1}{2} + 1$$；
  3. 所以$$log_m(n+1) \leqq h \leqq log_[m/2]\frac{n+1}{2}+1$$；

##### 查找

- B树的查找包含两个基本操作，在B树中找结点和在结点内找关键字；
- 由于B树常存储在磁盘上，因此前一个查找操作是在磁盘上进行的，而后一个查找操作是在内存中进行的，即在找到目标结点后，先将结点信息读入内存，然后在结点内采用顺序查找法或折半查找法；

##### 插入

- 将关键词key插入B树的过程如下：
  1. 定位：找出插入该关键词的最底层中的某个非叶结点；插入位置一定是最底层中某个非叶结点；
  2. 插入：每个非失败结点的关键字个数都在区间【[m/2]-1，m-1】，插入后的结点关键字个数小于m可以直接插入，插入后检查被插入结点内关键词个数大于m时，必须对结点进行分裂；
     - 分裂的方法：取一个新结点，在插入key后的原结点，从中间位置（[m/2]）将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置的关键字插入原结点的父结点；若此时，父结点的关键字个数也超过了上限，则继续这种分裂操作，直到过程传到根结点为止，进而导致树高增1；

##### 删除

- 但被删除结点不在终端结点（最底层非叶结点）中时，可以用k的前驱$$k'$$（或后继）来替代k，然后在相应的结点中删除$$k'$$，关键词$$k’$$必定落在某个终端结点中；
- 当被删除关键字在终端结点时，有三种情况：
  1. 直接删除关键字：删除该关键字后该结点的关键字个数$$\geqq[m/2]$$；
  2. 兄弟够借：若删除该关键字前该结点的关键字个数 = [m/2]-1.且于此结点相邻的右（或左）兄弟结点的关键字个数$$\geqq[m/2]$$，则需要调整该结点、右（左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡；
  3. 兄弟不够借：同2但此时与该结点相邻的左、右兄弟结点的关键字个数均 = [m/2] - 1，则将该关键字删除后与左（右）结点及双亲结点合并；
     - 在合并的过程中，双亲结点中的关键字个数会减1，若其双亲结点为根结点且关键字个数减少至0，则直接将根结点删除，合并后的新结点成为根结点；

#### B+树

##### 定义

- B+树是应数据库所需而出现的一种B树的变形树；一颗m阶B树需要满足：
  1. 每个分支结点最多有m颗子树；
  2. 非叶根结点至少含有两颗子树，其他每个分支结点至少有[m/2]颗子树；
  3. 结点的子树个数与关键字个数相等；
  4. 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字的大小顺序排列，并且相邻叶结点按大小顺序互相链接起来；
  5. 所有分支结点中仅包含它的各个子结点（即下一级的索引）中关键字的最大值及指向该结点的指针；

##### B树与B+树差异

1. 在B+树中，具有n个关键字的结点只含有n棵树，B树中则为n+1棵树；
2. B+树结点（非根结点）的关键字个数的范围$$[m/2]\leqq n\leqq m$$，根结点为$$2\leqq n \leqq m$$，而B树范围为$$[m/2]-1 \leqq n \leqq m-1$$，根结点为$$1 \leqq n \leqq m-1$$；
3. 在B+树中叶结点包含信息，所有非叶结点仅起索引作用，非叶结点的索引项只含有对应子树的最大关键字和指向该子树的指针，不含该关键字对应记录的存储地址；
4. 在B+树中，叶结点包含了所有关键字；而在B树中，叶结点（最外层内部结点）包含的关键字和其它结点包含的关键字是不重复的；

##### 查找

- B+树中有两个头指针，一个指向根结点，一个指向关键字最小的叶结点，因此查找可以从最小叶结点开始顺序查找、也可以从根结点开始多路查找；
- B+树查找时，要在叶结点上查找到关键字为止，无论查找是否成功，每次查找都是一条从根结点到叶结点的路径；

### 散列表

##### 定义

- 散列表：根据关键字而直接进行访问的数据结构；也就是说散列表建立了关键字和存储地址之间的一种直接映射关系；
- 理想情况下，散列表查找的时间复杂度为$$O(1)$$，即与表中元素个数无关；
- 散列函数：一个把查找表中的关键字映射成该关键字对应地址的函数，记为$$Hash(key) = Addr$$，这里的地址可以是数组下标、索引或内存地址等；
- 冲突：散列函数可能会把两个或两个以上的不同关键字映射到同一地址；
- 同义词：发生碰撞的不同关键词；
- 根据给定的关键字来计算关键字在表中的地址；

##### 散列函数构造方法

1. 直接定址法：直接取关键字的某个线性函数值为散列地址，散列函数为$$H(key)=key或H(key) = a*key+b$$；这种方法计算简单，且不会产生冲突，适合关键字分布基本连续的情况，若关键字分布不连续，空位较多，则会造成空间浪费；
2. 除留余数法：假定散列表表长为m，取一个不大于m但最接近或等于的质数p，利用$$H(key) = key \% p$$把关键字转化为地址；选好p使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性；
3. 数字分析法：适合于已知关键字集合，若更换了关键字，则需要重新构造新的散列函数；
4. 平方取中法：取关键字的平方值的中间几位作为散列地址；这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需要的位数；

##### 处理冲突的方法

1. 开放地址法：可存放新表项空闲地址既向它的同义词表项开放，又向它的非同义词表项开放：$$H_i = (H(key)+d_i)\%m$$；m为散列表表长，$$d_i$$为增量序列；
   - 线性探测法：$$d_i$$=0,1,2,...,k(k < m-1)；特点：冲突发生时，顺序查看表中下一单元，直到找出一个空闲单元或查遍全表；容易造成大量元素在相邻的散列地址上聚集，大大降低了查找效率；删除是添加删除标记；需要定期维护删除标记的元素物理删除；
   - 平方探测法：$$d_i = 0^2,1^2,-1^2,....,k^2,-k^2$$；$$k \leqq m/2$$；散列表的长度m必须是一个可以表示成4k+3的素数，又称二次探测法；可以避免出现堆积问题，缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元；
   - 双散列法：$$d_i = Hash_2(key)$$；$$H_i = RH_i(key)$$；初始探测位置$$H_0 = H(key)\%m$$，i是冲突次数，初始为0.最多经过m-1次探测就会遍历表中所有位置，回到$$H_0$$位置；
   - 伪随机序列法；
2. 拉链法（连接法 chaining）：把所有的同义词存储在一个线性链标准化，这个线性链表由其散列地址唯一标识；适用于经常插入删除的情况；

##### 查找

- 散列表的查找效率取决于三个因素：散列函数、处理冲突的方法、装填因子；
- 装填因子为$$\frac{表中记录数n}{散列表长度m}$$；
- 散列表的平均查找长度依赖于散列表的装填因子，而不直接依赖于n或m；装填因子越大，装填的记录越满，发生冲突的概率越大；